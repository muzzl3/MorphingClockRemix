// This is how many color levels the display shows - the more the slower the update
//#define PxMATRIX_COLOR_DEPTH 8

// Defines the buffer height / the maximum height of the matrix
//#define PxMATRIX_MAX_HEIGHT 64

// Defines the buffer width / the maximum width of the matrix
//#define PxMATRIX_MAX_WIDTH 64

// Defines how long we display things by default
//#define PxMATRIX_DEFAULT_SHOWTIME 30

// Defines the speed of the SPI bus (reducing this may help if you experience noisy images)
//#define PxMATRIX_SPI_FREQEUNCY 20000000

// Creates a second buffer for backround drawing (doubles the required RAM)
//#define PxMATRIX_double_buffer true

#include <PxMatrix.h>

// Pins for LED MATRIX
#ifdef ESP32

#define P_LAT 22
#define P_A 19
#define P_B 23
#define P_C 18
#define P_D 5
#define P_E 15
#define P_OE 2
hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

#endif

#ifdef ESP8266

#include <Ticker.h>
Ticker display_ticker;
#define P_LAT 16
#define P_A 5
#define P_B 4
#define P_C 15
#define P_D 12
#define P_E 0
#define P_OE 2

#endif


// This defines the 'on' time of the display is us. The larger this number,
// the brighter the display. If too large the ESP will crash
uint8_t display_draw_time=20; //10-50 is usually fine

//PxMATRIX display(32,16,P_LAT, P_OE,P_A,P_B,P_C);
PxMATRIX display(64,32,P_LAT, P_OE,P_A,P_B,P_C,P_D);
//PxMATRIX display(64,64,P_LAT, P_OE,P_A,P_B,P_C,P_D,P_E);

// Some standard colors
uint16_t myRED = display.color565(175, 0, 0);
uint16_t myGREEN = display.color565(0, 175, 0);
uint16_t myBLUE = display.color565(0, 0, 255);;
uint16_t myWHITE = display.color565(100, 100, 100);
uint16_t myYELLOW = display.color565(175, 255, 0);
uint16_t myCYAN = display.color565(0, 175, 175);
uint16_t myMAGENTA = display.color565(175, 0, 255);
uint16_t myBLACK = display.color565(0, 0, 0);
uint16_t myGOLD = display.color565(255,215,0);

uint16_t myClockColour = myBLUE;
uint16_t myDateColour = myCYAN;
uint16_t myTempColour = myRED;
uint16_t myTempForcstColour = myYELLOW;
uint16_t myPressureColour = myGREEN;
uint16_t myHumidityColour = myWHITE;

String bMessage = "MORPH CLOCK";

bool myClockOn = 1;
bool myDateOn = 1;
bool myTempOn = 1;
bool myTempFCOn = 1;
bool myPressOn = 1;
bool myHumidityOn = 1;

uint8_t static weather_icons[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00
  ,0x00,0x20,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x07,0xdf,0x07,0xdf,0x07,0xff,0xff,0xe0,0xff,0xe0,0x00,0x00
  ,0x00,0x00,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0xff,0xe0,0x00,0x20,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0xff,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x07,0xff,0x00,0x20,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00
  ,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xdf,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

#define double_buffer

#include <TimeLib.h>
#include <NtpClientLib.h>
#include <ESP8266WiFi.h>

//=== WIFI MANAGER ===
#include <DNSServer.h>
#include <ESP8266WebServer.h>
#include <WiFiManager.h> //https://github.com/tzapu/WiFiManager
char wifiManagerAPName[] = "MorphClk";
char wifiManagerAPPassword[] = "MorphClk";

//== DOUBLE-RESET DETECTOR ==
#include <DoubleResetDetector.h>
#define DRD_TIMEOUT 10 // Second-reset must happen within 10 seconds of first reset to be considered a double-reset
#define DRD_ADDRESS 0 // RTC Memory Address for the DoubleResetDetector to use
DoubleResetDetector drd(DRD_TIMEOUT, DRD_ADDRESS);

//== SAVING CONFIG ==
#include "FS.h"
#include <ArduinoJson.h>
bool shouldSaveConfig = false; // flag for saving data

//callback notifying us of the need to save config
void saveConfigCallback () 
{
  Serial.println("Should save config");
  shouldSaveConfig = true;
}

//=== SEGMENTS ===
int cin = 25; //color intensity
#include "Digit.h"
Digit digit0(&display, 0, 63 - 1 - 9*1, 8, myClockColour);
Digit digit1(&display, 0, 63 - 1 - 9*2, 8, myClockColour);
Digit digit2(&display, 0, 63 - 4 - 9*3, 8, myClockColour);
Digit digit3(&display, 0, 63 - 4 - 9*4, 8, myClockColour);
Digit digit4(&display, 0, 63 - 7 - 9*5, 8, myClockColour);
Digit digit5(&display, 0, 63 - 7 - 9*6, 8, myClockColour);

#ifdef ESP8266
// ISR for display refresh
void display_updater()
{
  display.display(display_draw_time);
}
#endif


void getWeather ();

void configModeCallback (WiFiManager *myWiFiManager) 
{
  Serial.println ("Entered config mode");
  Serial.println (WiFi.softAPIP());

  // You could indicate on your screen or by an LED you are in config mode here

  // We don't want the next time the boar resets to be considered a double reset
  // so we remove the flag
  drd.stop ();
}

char weatherLoc[40] = "";
char weatherAPLI[64] = "";
char timezone[5] = "12";
char military[3] = "Y";     // 24 hour mode? Y/N
char u_metric[3] = "Y";     // use metric for units? Y/N
char date_fmt[7] = "D.M.Y"; // date format: D.M.Y or M.D.Y or M.D or D.M or D/M/Y.. looking for trouble
bool loadConfig () 
{
  File configFile = SPIFFS.open ("/config.json", "r");
  if (!configFile) 
  {
    Serial.println("Failed to open config file");
    return false;
  }

  size_t size = configFile.size ();
  if (size > 1024) 
  {
    Serial.println("Config file size is too large");
    return false;
  }

  // Allocate a buffer to store contents of the file.
  std::unique_ptr<char[]> buf(new char[size]);

  configFile.readBytes (buf.get(), size);

  StaticJsonBuffer<200> jsonBuffer;
  JsonObject& json = jsonBuffer.parseObject(buf.get());

  if (!json.success ()) 
  {
    Serial.println("Failed to parse config file");
    return false;
  }

  strcpy (timezone, json["timezone"]);
  strcpy (military, json["military"]);
  //avoid reboot loop on systems where this is not set
  if (json.get<const char*>("metric"))
    strcpy (u_metric, json["metric"]);
  else
  {
    Serial.println ("metric units not set, using default: Y");
  }
  if (json.get<const char*>("date-format"))
    strcpy (date_fmt, json["date-format"]);
  else
  {
    Serial.println ("date format not set, using default: D.M.Y");
  }
  
  return true;
}

bool saveConfig () 
{
  StaticJsonBuffer<200> jsonBuffer;
  JsonObject& json = jsonBuffer.createObject();
  json["timezone"] = timezone;
  json["military"] = military;
  json["metric"] = u_metric;
  json["date-format"] = date_fmt;

  File configFile = SPIFFS.open ("/config.json", "w");
  if (!configFile)
  {
    Serial.println ("Failed to open config file for writing");
    return false;
  }

  Serial.println ("Saving configuration to file:");
  Serial.print ("timezone=");
  Serial.println (timezone);
  Serial.print ("military=");
  Serial.println (military);
  Serial.print ("metric=");
  Serial.println (u_metric);
  Serial.print ("date-format=");
  Serial.println (date_fmt);

  json.printTo (configFile);
  return true;
}

#include "TinyFont.h"
const byte row0 = 2+0*10;
const byte row1 = 2+1*10;
const byte row2 = 2+2*10;
void wifi_setup ()
{
  //-- Config --
  if (!SPIFFS.begin ()) 
  {
    Serial.println ("Failed to mount FS");
    return;
  }
  loadConfig ();

  //-- Display --
  display.fillScreen (myBLACK);
  display.setTextColor (myBLUE);

  //-- WiFiManager --
  //Local intialization. Once its business is done, there is no need to keep it around
  WiFiManager wifiManager;
  wifiManager.setSaveConfigCallback (saveConfigCallback);
  WiFiManagerParameter timeZoneParameter ("timeZone", "Time Zone", timezone, 5); 
  wifiManager.addParameter (&timeZoneParameter);
  WiFiManagerParameter militaryParameter ("military", "24Hr (Y/N)", military, 3); 
  wifiManager.addParameter (&militaryParameter);
  WiFiManagerParameter metricParameter ("metric", "Metric Units (Y/N)", u_metric, 3); 
  wifiManager.addParameter (&metricParameter);
  WiFiManagerParameter dmydateParameter ("date_fmt", "Date Format (D.M.Y)", date_fmt, 6); 
  wifiManager.addParameter (&dmydateParameter);

  //-- Double-Reset --
  if (drd.detectDoubleReset ()) 
  {
    Serial.println ("Double Reset Detected");    
    TFDrawText (&display, String("Double Reset"), 0, 13, myBLUE);

    display.setCursor (0, row0);
    display.print ("AP:");
    display.print (wifiManagerAPName);

    display.setCursor (0, row1);
    display.print ("Pw:");
    display.print (wifiManagerAPPassword);

    //display.setCursor (0, row2);
    //display.print ("192.168.4.1");

    wifiManager.startConfigPortal (wifiManagerAPName, wifiManagerAPPassword);

    display.fillScreen (myBLACK));
  } 
  else 
  {
    Serial.println ("No Double Reset Detected");
    TFDrawText (&display, String("Reset"), 0, 13, myBLUE);
    //display.setCursor (2, row1);
    //display.print ("connecting");
    TFDrawText (&display, String("CONNECTING..."), 0, 13, myBLUE);

    //fetches ssid and pass from eeprom and tries to connect
    //if it does not connect it starts an access point with the specified name wifiManagerAPName
    //and goes into a blocking loop awaiting configuration
    wifiManager.autoConnect (wifiManagerAPName);
  }
  
  Serial.print ("timezone=");
  Serial.println (timezone);
  Serial.print ("military=");
  Serial.println (military);
  Serial.print ("metric=");
  Serial.println (u_metric);
  Serial.print ("date-format=");
  Serial.println (date_fmt);
  //timezone
  strcpy (timezone, timeZoneParameter.getValue ());
  //military time
  strcpy (military, militaryParameter.getValue ());
  //metric units
  strcpy (u_metric, metricParameter.getValue ());
  //date format
  strcpy (date_fmt, dmydateParameter.getValue ());
  //display.fillScreen (0);
  //display.setCursor (2, row1);
  TFDrawText (&display, String("     ONLINE     "), 0, 13, myBLUE);
  Serial.print ("WiFi connected, IP address: ");
  Serial.println (WiFi.localIP ());
  //
  //start NTP
  NTP.begin ("pool.ntp.org", String(timezone).toInt(), false);
  NTP.setInterval (10);//force rapid sync in 10sec

  if (shouldSaveConfig) 
  {
    saveConfig ();
  }
  drd.stop ();
  
  //delay (1500);
  getWeather ();
}

byte hh;
byte mm;
byte ss;
byte ntpsync = 1;

void ntpSetup()
{
  NTP.onNTPSyncEvent ([](NTPSyncEvent_t ntpEvent) 
  {
    if (ntpEvent) 
    {
      Serial.print ("Time Sync error: ");
      if (ntpEvent == noResponse)
        Serial.println ("NTP server not reachable");
      else if (ntpEvent == invalidAddress)
        Serial.println ("Invalid NTP server address");
    }
    else 
    {
      Serial.print ("Got NTP time: ");
      Serial.println (NTP.getTimeDateString (NTP.getLastNTPSync ()));
      ntpsync = 1;
    }
  });
}

#ifdef ESP32
void IRAM_ATTR display_updater(){
  // Increment the counter and set the time of ISR
  portENTER_CRITICAL_ISR(&timerMux);
  display.display(display_draw_time);
  portEXIT_CRITICAL_ISR(&timerMux);
}
#endif


void display_update_enable(bool is_enable)
{  
  #ifdef ESP8266
    if (is_enable)
      display_ticker.attach(0.002, display_updater);
    else
      display_ticker.detach();
  #endif
  
  #ifdef ESP32
    if (is_enable)
    {
      timer = timerBegin(0, 80, true);
      timerAttachInterrupt(timer, &display_updater, true);
      timerAlarmWrite(timer, 2000, true);
      timerAlarmEnable(timer);
    }
    else
    {
      timerDetachInterrupt(timer);
      timerAlarmDisable(timer);
    }
  #endif
}

void clockDisplaySetup()
{
  //prep screen for clock display
  display.fillScreen (0);
  
  //reset digits color
  digit0.SetColor (myClockColour);
  digit1.SetColor (myClockColour);
  digit2.SetColor (myClockColour);
  digit3.SetColor (myClockColour);
  digit4.SetColor (myClockColour);
  digit5.SetColor (myClockColour);
  //digit1.DrawColon (myClockColour);
  digit3.DrawColon (myClockColour);  
}

void setup() {

 Serial.begin(9600);
  // Define your display layout here, e.g. 1/8 step, and optional SPI pins begin(row_pattern, CLK, MOSI, MISO, SS)
  display.begin(16);
  //display.begin(8, 14, 13, 12, 4);

  //Add PXMatrix configurations here as required.

  display.setFastUpdate(true);
  display.clearDisplay();  
  display_update_enable(true);

  delay(3000);
  display.clearDisplay();

  wifi_setup ();
  ntpSetup();
  clockDisplaySetup();
}

union single_double{
  uint8_t two[2];
  uint16_t one;
} this_single_double;

// This draws the weather icons
void draw_weather_icon (uint8_t icon)
{
  if (icon>10)
  icon=10;
  for (int yy=0; yy<10;yy++)
  {
    for (int xx=0; xx<10;xx++)
    {
      uint16_t byte_pos=(xx+icon*10)*2+yy*220;
      this_single_double.two[1]=weather_icons[byte_pos];
      this_single_double.two[0]=weather_icons[byte_pos+1];
      display.drawPixel(1+xx,yy,this_single_double.one);
    }
  }
}

uint8_t icon_index=0;
void loop() {
  runMorphTime();
}

void runDemo()
{  
  draw_weather_icon(icon_index);
  icon_index++;
  if (icon_index>10)
    icon_index=0;

  delay(1000);
  for (uint8_t dimm=255; dimm>0; dimm--)
  {
    display.setBrightness(dimm);
    delay(5);
  }
  for (uint8_t dimm=0; dimm<255; dimm++)
  {
    display.setBrightness(dimm);
    delay(5);
  }
}

void drawBinarySeconds(byte ss)
{
  int xo1 = 63 - 7 - 9 - 4;
  int xo2 = xo1+1;
  int xo3 = xo2+1;
  int xo4 = xo3+1;

  int yo0 = 9;
  int yo1 = yo0+15;
  
  int lenRow1 = min(int(ss),15);
  int lenRow2 = min(int(ss)-15,15); 
  int lenRow3 = min(int(ss)-30,15);    
  int lenRow4 = min(int(ss)-45,15); 

  //black out the area
  //TODO: should use a rectangle
  display.drawLine(xo1,yo0,xo1,yo1,myBLACK);
  display.drawLine(xo2,yo0,xo2,yo1,myBLACK);
  display.drawLine(xo3,yo0,xo3,yo1,myBLACK);
  display.drawLine(xo4,yo0,xo4,yo1,myBLACK);

  if (ss >= 1)  {    display.drawLine(xo1,yo0,xo1,yo0+lenRow1-1,myGOLD);  }
  if (ss >= 15)  {          display.drawLine(xo2,yo0,xo2,yo0+lenRow2-1,myGOLD);    }
  if (ss >= 30)  {      display.drawLine(xo3,yo0,xo3,yo0+lenRow3-1,myGOLD);  }
  if (ss >= 45)  {    display.drawLine(xo4,yo0,xo4,yo0+lenRow4-1,myGOLD);  }  
  
}

//####MORPHTIME REMIX STUFF BELOW HERE####
//open weather map api key 
String apiKey   = ""; //e.g a hex string like "abcdef0123456789abcdef0123456789"
//the city you want the weather for 
String location = ""; //e.g. "Paris,FR"
char server[]   = "api.openweathermap.org";
WiFiClient client;
int tempMin = -10000;
int tempMax = -10000;
int tempM = -10000;
int presM = -10000;
int humiM = -10000;
int condM = -1;  //-1 - undefined, 0 - unk, 1 - sunny, 2 - cloudy, 3 - overcast, 4 - rainy, 5 - thunders, 6 - snow
String condS = "";
void getWeather ()
{
  if (!apiKey.length ())
  {
    Serial.println ("w:missing API KEY for weather data, skipping"); 
    return;
  }
  Serial.print ("i:connecting to weather server.. "); 
  // if you get a connection, report back via serial: 
  if (client.connect (server, 80))
  { 
    Serial.println ("connected."); 
    // Make a HTTP request: 
    client.print ("GET /data/2.5/weather?"); 
    client.print ("q="+location); 
    client.print ("&appid="+apiKey); 
    client.print ("&cnt=1"); 
    (*u_metric=='Y')?client.println ("&units=metric"):client.println ("&units=imperial");
    client.println ("Host: api.openweathermap.org"); 
    client.println ("Connection: close");
    client.println (); 
  } 
  else 
  { 
    Serial.println ("w:unable to connect");
    return;
  } 
  delay (1000);
  String sval = "";
  int bT, bT2;
  //do your best
  String line = client.readStringUntil ('\n');
  if (!line.length ())
    Serial.println ("w:unable to retrieve weather data");
  else
  {
    Serial.print ("weather:"); 
    Serial.println (line); 
    //weather conditions - "main":"Clear",
    bT = line.indexOf ("\"main\":\"");
    if (bT > 0)
    {
      bT2 = line.indexOf ("\",\"", bT + 8);
      sval = line.substring (bT + 8, bT2);
      Serial.print ("cond ");
      Serial.println (sval);
      //0 - unk, 1 - sunny, 2 - cloudy, 3 - overcast, 4 - rainy, 5 - thunders, 6 - snow
      condM = 0;
      if (sval.equals("Clear"))
        condM = 1;
      else if (sval.equals("Clouds"))
        condM = 2;
      else if (sval.equals("Overcast"))
        condM = 3;
      else if (sval.equals("Rain"))
        condM = 4;
      else if (sval.equals("Drizzle"))
        condM = 4;
      else if (sval.equals("Thunderstorm"))
        condM = 5;
      else if (sval.equals("Snow"))
        condM = 6;
      //
      condS = sval;
      Serial.print ("condM ");
      Serial.println (condM);
    }
    //tempM
    bT = line.indexOf ("\"temp\":");
    if (bT > 0)
    {
      bT2 = line.indexOf (",\"", bT + 7);
      sval = line.substring (bT + 7, bT2);
      Serial.print ("temp: ");
      Serial.println (sval);
      tempM = sval.toInt ();
    }
    else
      Serial.println ("temp NOT found!");
    //tempMin
    bT = line.indexOf ("\"temp_min\":");
    if (bT > 0)
    {
      bT2 = line.indexOf (",\"", bT + 11);
      sval = line.substring (bT + 11, bT2);
      Serial.print ("temp min: ");
      Serial.println (sval);
      tempMin = sval.toInt ();
    }
    else
      Serial.println ("temp_min NOT found!");
    //tempMax
    bT = line.indexOf ("\"temp_max\":");
    if (bT > 0)
    {
      bT2 = line.indexOf ("},", bT + 11);
      sval = line.substring (bT + 11, bT2);
      Serial.print ("temp max: ");
      Serial.println (sval);
      tempMax = sval.toInt ();
    }
    else
      Serial.println ("temp_max NOT found!");
    //pressM
    bT = line.indexOf ("\"pressure\":");
    if (bT > 0)
    {
      bT2 = line.indexOf (",\"", bT + 11);
      sval = line.substring (bT + 11, bT2);
      Serial.print ("press ");
      Serial.println (sval);
      presM = sval.toInt();
    }
    else
      Serial.println ("pressure NOT found!");
    //humiM
    bT = line.indexOf ("\"humidity\":");
    if (bT > 0)
    {
      bT2 = line.indexOf (",\"", bT + 11);
      sval = line.substring (bT + 11, bT2);
      Serial.print ("humi ");
      Serial.println (sval);
      humiM = sval.toInt();
    }
    else
      Serial.println ("humidity NOT found!");
  }//connected
}

void draw_weather ()
{  
  int xo;
  int yo;
  Serial.println ("showing the weather");
  xo = 0; yo = 1;
  //TFDrawText (&display, String("                "), xo, yo, myBLUE);
  if (tempM == -10000 || humiM == -10000 || presM == -10000)
  {
    //TFDrawText (&display, String("NO WEATHER DATA"), xo, yo, cc_dgr);
    Serial.println ("!no weather data available");
  }
  else
  {
    //####weather####
    //-temperature
    String lstr = String (tempM) + String((*u_metric=='Y')?"C":"F");
    //Serial.print ("temperature: ");
    //Serial.println (lstr);
    xo = 64-13;//8*TF_COLS;
    yo = (1*6)+2;
    if (!myTempOn)
    {
      lstr = "";
    }
    TFDrawText (&display, lstr, xo, yo, myTempColour);
    
    //***humidity
    lstr = String (humiM) + "%";
    xo = 64-13;//8*TF_COLS;
    yo = (6*2) + 2;
    if (!myHumidityOn)
    {
      lstr = "";
    }
    TFDrawText (&display, lstr, xo, yo, myHumidityColour);
    
    //***pressure
    lstr = String (presM);
    xo = 64-(4*4)-1;//12*TF_COLS;
    yo = (6*3) + 2;
    if (!myPressOn)
    {
      lstr = "";
    }
    TFDrawText (&display, lstr, xo, yo, myPressureColour);
    
    //***draw temp min/max
    if (tempMin > -10000)
    {
      xo = 64-(3*4*2)-1;//0*TF_COLS; 
      yo = (5*5)+1;//26;
      lstr = String (tempMin) + "-";
      if (tempMin < 0)
      {
        lstr = String (-tempMin) + "-";
      }
      if (myTempFCOn)
      {
        lstr = "";
      }
      TFDrawText (&display, lstr, xo, yo, myTempForcstColour);
    }
    if (tempMax > -10000)
    {
      //move the text to the right or left as needed
      xo = 64-(3*4)-1;//14*TF_COLS; 
      yo = (5*5)+1;//26;
      lstr = String (tempMax) + String((*u_metric=='Y')?"C":"F");
      if (tempMax < 0)
      {
        lstr = String (-tempMax) + String((*u_metric=='Y')?"C":"F");
      }
      if (myTempFCOn)
      {
        lstr = "";
      }
      TFDrawText (&display, lstr, xo, yo, myTempForcstColour);
    }
  }
}

//
void draw_date ()
{
  //date below the clock
  long tnow = now();
  String lstr = "";
  for (int i = 0; i < 5; i += 2)
  {
    switch (date_fmt[i])
    {
      case 'D':
        lstr += (day(tnow) < 10 ? "0" + String(day(tnow)) : String(day(tnow)));
        if (i < 4)
          lstr += date_fmt[i + 1];
        break;
      case 'M':
        lstr += (month(tnow) < 10 ? "0" + String(month(tnow)) : String(month(tnow)));
        if (i < 4)
          lstr += date_fmt[i + 1];
        break;
      //case 'Y':
      //  lstr += String(year(tnow));
      //  if (i < 4)
      //    lstr += date_fmt[i + 1];
      //  break;
    }
  }
  //
  if (lstr.length())
  {
    //
    int xo = 2;//3*TF_COLS; 
    int yo = 32-(1*5)-1;
    TFDrawText (&display, lstr, xo, yo, myDateColour);
  }
}

void changeColours (uint16_t hh, uint16_t mm, uint16_t ss)
{
    //reset digits color
    digit0.SetColor (myClockColour);
    digit1.SetColor (myClockColour);
    digit2.SetColor (myClockColour);
    digit3.SetColor (myClockColour);
    digit4.SetColor (myClockColour);
    digit5.SetColor (myClockColour);    
    //digit1.DrawColon (myClockColour);
    digit3.DrawColon (myClockColour);
}

#include <ESP8266HTTPClient.h>
#include <ArduinoJson.h>
void loadSettingsFromWebJSON ()
{
  HTTPClient http;  //Object of class HTTPClient
  http.begin("https://prod-26.australiasoutheast.logic.azure.com:443/workflows/");
  int httpCode = http.GET();
  
  //Check the returning code                                                                  
  if (httpCode > 0) {
    // Parsing
    const size_t bufferSize = JSON_OBJECT_SIZE(2) + JSON_OBJECT_SIZE(3) + JSON_OBJECT_SIZE(5) + JSON_OBJECT_SIZE(8) + 370;
    DynamicJsonBuffer jsonBuffer(bufferSize);
    JsonObject& JSONRoot = jsonBuffer.parseObject(http.getString());

    //Bulletin message
    bMessage = (char)JSONRoot["bMessage"];
    
    //Set colours
    myClockColour = display.color565((char)JSONRoot["myClockColour"]["r"],(char)JSONRoot["myClockColour"]["g"],(char)JSONRoot["myClockColour"]["b"]);
    myDateColour = display.color565((char)JSONRoot["myClockColour"]["r"],(char)JSONRoot["myClockColour"]["g"],(char)JSONRoot["myClockColour"]["b"]);
    myTempColour = display.color565((char)JSONRoot["myClockColour"]["r"],(char)JSONRoot["myClockColour"]["g"],(char)JSONRoot["myClockColour"]["b"]);
    myTempForcstColour = display.color565((char)JSONRoot["myClockColour"]["r"],(char)JSONRoot["myClockColour"]["g"],(char)JSONRoot["myClockColour"]["b"]);
    myPressureColour = display.color565((char)JSONRoot["myClockColour"]["r"],(char)JSONRoot["myClockColour"]["g"],(char)JSONRoot["myClockColour"]["b"]);
    myHumidityColour = display.color565((char)JSONRoot["myClockColour"]["r"],(char)JSONRoot["myClockColour"]["g"],(char)JSONRoot["myClockColour"]["b"]);
    
    //Enable/disable displays
    myClockOn = (bool)JSONRoot["outputFlags"]["myClockOn"];
    myDateOn = (bool)JSONRoot["outputFlags"]["myDateOn"]; 
    myTempOn = (bool)JSONRoot["outputFlags"]["myTempOn"];     
    myTempFCOn = (bool)JSONRoot["outputFlags"]["myTempFCOn"];     
    myPressOn = (bool)JSONRoot["outputFlags"]["myPressOn"];     
    myHumidityOn = (bool)JSONRoot["outputFlags"]["myHumidityOn"]; 
    
  }
  
  http.end();   //Close connection
}

byte prevhh = 0;
byte prevmm = 0;
byte prevss = 0;
long tnow;
void runMorphTime()
{
  static int i = 0;
  static int last = 0;
  static int cm;
  //time changes every miliseconds, we only want to draw when digits actually change
  tnow = now ();

  hh = hour (tnow);   //NTP.getHour ();
  mm = minute (tnow); //NTP.getMinute ();
  ss = second (tnow); //NTP.getSecond ();
  //animations?
  cm = millis ();

  //###TIME UPDATE
  if (ntpsync)
  {
    ntpsync = 0;
    //
    prevss = ss;
    prevmm = mm;
    prevhh = hh;
    
    loadSettingsFromWebJSON();
    changeColours(hh,mm,ss);    
    TFDrawText (&display, String(bMessage), 1, 1, myBLUE);
 
    //clear screen
    display.fillScreen (0);
    //date and weather
    draw_weather ();
    draw_date ();

    //military time?
    if (hh > 12 && military[0] == 'N')
      hh -= 12;

    //drawBinarySeconds(ss);
    //digit0.Draw (ss % 10);
    //digit1.Draw (ss / 10);
    digit2.Draw (mm % 10);
    digit3.Draw (mm / 10);
    digit4.Draw (hh % 10);
    digit5.Draw (hh / 10);
  }
  else
  {    
    
    //seconds
    if (ss != prevss) 
    {      
      //drawBinarySeconds(ss);
      int s0 = ss % 10;
      int s1 = ss / 10;
      //if (s0 != digit0.Value ()) digit0.Morph (s0);
      //if (s1 != digit1.Value ()) digit1.Morph (s1);
      //ntpClient.PrintTime();
      prevss = ss;
      //refresh weather every 5mins at 30sec in the minute
      if (ss == 30 && ((mm % 5) == 0))
        getWeather ();
    }
    //minutes
    if (mm != prevmm)
    {
      
      int m0 = mm % 10;
      int m1 = mm / 10;
      
      //update settings every 5 minutes.
      if (m1 == 5 || m1 == 0)
      {
        loadSettingsFromWebJSON();        
        changeColours(hh,mm,ss);    
        TFDrawText (&display, String(bMessage), 1, 1, myBLUE);
      }
      
      if (m0 != digit2.Value ()) digit2.Morph (m0);
      if (m1 != digit3.Value ()) digit3.Morph (m1);
      prevmm = mm;
    }
    //hours
    if (hh != prevhh) 
    {
      prevhh = hh;
      //
      draw_date ();
      //brightness control: dimmed during the night(25), bright during the day(150)
      if (hh == 20 || hh == 8)
      {
        ntpsync = 1;
        //bri change is taken care of due to the sync
      }
      //military time?
      if (hh > 12 && military[0] == 'N')
        hh -= 12;
      //
      int h0 = hh % 10;
      int h1 = hh / 10;
      if (h0 != digit4.Value ()) digit4.Morph (h0);
      if (h1 != digit5.Value ()) digit5.Morph (h1);
    }//hh changed
  }
  //set NTP sync interval as needed
  if (NTP.getInterval() < 3600 && year(now()) > 1970)
  {
    //reset the sync interval if we're already in sync
    NTP.setInterval (3600 * 24);//re-sync once a day
  }
  //
  //delay (0);
}
